# Project Overview

Hack Club Lapse is a web app for recording timelapses created in Next.js, TypeScript, tRPC, Prisma ORM, and Tailwind CSS. It uses pnpm as its package manager. We use Pages Router with Next.js v15 to limit the use of server components.

We define the following entities:
- **timelapse** - a short video file, owned by a user.
- **snapshot** - a description for a single frame in a timelapse. Snapshots define the timestamps for each frame in a timelapse.
- **user** - a user of the service.
- **device** - a device, assigned to a user, which contains a passkey used for encryption. The passkey is generated on the client, and is stored *only* on the client.
- **streaming_session** - a record of an active or completed OBS streaming session. Contains Cloudflare live input and recording IDs.

These are described by the models defined in `prisma/schema.prisma`.

## Recording Methods

Lapse supports two methods for creating timelapses:

### Local Recording / Browser Recording
Users record timelapses by taking snapshots in their browser (via camera or file upload), which are combined into a timelapse video. All processing happens client-side:
1. User takes snapshots locally
2. Browser combines snapshots into video
3. Browser encrypts with device passkey (AES-256-CBC)
4. Browser uploads encrypted timelapse to R2

### Streaming
Users can stream directly from OBS, Streamlabs, or any RTMP-compatible application to Lapse via Cloudflare Stream:
1. User initiates streaming session with name, description, and privacy preference
2. Cloudflare Stream generates RTMPS credentials (unique per session)
3. User configures OBS with provided RTMPS URL and stream key
4. Stream is recorded automatically by Cloudflare Stream
5. User stops stream from the Lapse UI
6. Server downloads recording from Cloudflare
7. Server encrypts with device passkey (same method as local recordings)
8. Server uploads encrypted timelapse to R2
9. Streaming session is cleaned up and converted to timelapse record

## Privacy During Streaming

Streaming supports privacy controls during the broadcast:
- **Private stream** (default) - Only the streaming user can view the live broadcast on Cloudflare
- **Public stream** - Anyone can watch the live stream (optional)

After streaming completes, users choose the final timelapse visibility independently:
- **Public** - Listed on the public gallery
- **Unlisted** - Only visible to author, admins, and users with private URL

## Encryption

Timelapses are stored locally on the user's browser. It is paramount that timelapses stay private and accessible only to the user before they're reviewed and/or edited by the user. However, the user might want to record timelapses on one device, and edit/review them on another. For this reason, timelapses are *encrypted* with an auto-generated passkey, generated by each device, only accessible to the user.


**Streaming:**
1. RTMPS connection (TLS encrypted) between OBS and Cloudflare Stream
2. Cloudflare Stream records broadcast (temporarily unencrypted on Cloudflare)
3. Server downloads recording from Cloudflare via HTTPS
4. Server temporarily decrypts in memory (necessary for thumbnail generation and validation)
5. Server re-encrypts with device passkey (AES-256-CBC)
6. Server uploads encrypted timelapse to R2
7. Recording is deleted from Cloudflare

Device passphrases are generated per device and stored only on the client. The server never receives or stores device passphrases, ensuring that encrypted timelapses remain accessible only to the user and their devices.

## Publishing

When a timelapse is published, it can either be set to **public** or **unlisted**. An *unlisted* timelapse can only be viewed by administrators and the author, as well as anyone with a private, uniquely generated URL. A *public* timelapse is publicly shared on the website.

## Integration

Lapse has the ability to import data to an API-compatible WakaTime fork called Hackatime. When importing, a WakaTime heartbeat will be created for each *snapshot*.

## Code Organization

This project features clear client/server separation. A file should never combine client-side and server-side code.

**Client-side code** handles:
- Snapshot capture and recording
- Device passkey generation and storage
- Encryption of local recordings
- Timelapse editing and preview
- OBS streaming setup and monitoring

**Server-side code** handles:
- Cloudflare Stream integration
- Recording download and processing
- Timelapse encryption (for streamed content)
- Database operations
- Authentication and authorization

# Code style

- Use double quotes for strings.
- Always use semicolons.
- Avoid braces for if/else blocks that return or throw.
- Use 2 spaces as indentation for TSX files.
- Use 4 spaces as indentation for TypeScript files.
- Avoid creating comments for self-documenting code.

**Always** put `catch` and `else` blocks on their own line. For example:
```
try {
    // ...
}
catch {
    // ...
}

if (...) {

}
else if (...) {

}
else {

}
```

# Rules

- Avoid using the `any` type.
- All code should be strongly typed.
- Prefer using Prisma's UUID generation rather than APIs like `crypto.randomUUID`.
- Avoid using server components without a clear client/server separation.
- Do not run linters. You may verify the code style with ESLint, but do not run code formatters.
- Do not attempt to preview the site or run the server by yourself.
